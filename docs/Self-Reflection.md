### Self-Reflection  
**CP3406 Assignment 2 – Book Reading Tracker**  


Throughout the entire development process of Assignment 2, the most unforgettable experience for me occurred with the search function on the Discover page. As a user, I clearly entered book titles such as “Kotlin” or “Atomic Habits” in the search box—keywords that should definitely return results—and clicked the search button, yet the page displayed nothing. The list remained completely empty, with no message like “No books found” or “Network error”, and at most the loading indicator flashed briefly before the program appeared to stop responding entirely. At that moment I was completely stunned, because search is a critical part of this app—if it doesn’t work, half the application is effectively broken.

When I first discovered the problem, I felt extremely anxious and even suspected that the network code had completely collapsed. I tried countless different keywords and clicked search over and over again; after more than a dozen attempts the result was still the same blank screen. The intense frustration made me briefly want to rewrite the entire page from scratch. Eventually I forced myself to calm down, first carefully recorded the steps to reproduce the issue, then opened Logcat, examined the logs line by line, and added print statements in the ViewModel. Finally I discovered the real cause: changes in the search box text were not being synchronized to the ViewModel in real time, so when the search button was clicked it was still using the previous empty string. The request was never actually sent.

The instant I located the problem, I let out a long breath of relief. All the previous anxiety vanished in a second, leaving only some self-reproach for my carelessness and a small sense of accomplishment for solving the puzzle.

Looking back, what I did well was that I didn’t start randomly changing code in a panic; instead I patiently traced the issue step by step from the UI to the ViewModel state and then to the logs, eventually pinpointing it accurately. However, what I clearly did poorly was that I provided absolutely no visual feedback for empty results, network errors, or the loading state. Users had no way of knowing whether nothing was found or the request never went out at all. Even worse, the UI tests only verified that the search method was called and never simulated the complete chain from real user input to list rendering, so this critical problem stayed hidden until manual testing.

This experience made me truly understand that even the simplest search function is actually a fragile closed loop: user input, real-time state update, click trigger, loading feedback, and then success or empty result or error message. If any single link breaks, what the user perceives is “the app is broken”. In the past I always thought that an empty result could just stay empty, but now I realize every possible situation must be clearly communicated to the user so they feel the app is trustworthy and under control.

Next time I work on a similar project, I will immediately make the search box text update the ViewModel in real time, so the button only triggers the latest state, and I will enforce loading skeletons, friendly empty-result illustrations and copy, and error Snackbars. For testing, I will add at least three end-to-end Compose UI tests covering normal results, empty results, and no-network scenarios. From now on, whenever I add a new feature, I will always run through the entire flow on a real device instead of relaxing once the unit tests turn green.

Although this incident made me anxious for several hours, it also deeply engraved the importance of state management, user feedback, and end-to-end testing into my mind. In the future, whenever I implement search, lists, or asynchronous loading features, I will always ask myself: “If nothing comes back, will the user know what happened?” With this lesson, I am confident the next project will be much more solid and reliable.

